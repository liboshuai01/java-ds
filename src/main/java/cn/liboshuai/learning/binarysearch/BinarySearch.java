package cn.liboshuai.learning.binarysearch;

public class BinarySearch {

    /**
     * 二分查找 基础版本
     *
     * @param a      被查找的升序数组
     * @param target 需要被找到的目标元素值
     * @return 目标元素值的数组索引下标（如果没有找到元素，则索引下标返回-1）
     * 时间复杂度：O(logN)
     * 空间复杂度：O(1)
     * 知识点：
     * 1. 二分查找算法的原理
     * 2. 求中间数使用(j+i)/2时，int数据类型溢出，导致出现负数问题
     * - 1. 原码、反码、补码，为什么计算机底层存储的都是补码，它解决了什么问题？
     * - 2. Java程序中的数据类型位数是什么？为什么不同位数的数据类型，能使用的数据范围不一样？
     * - 3. 简单数学公式转换，将(j+i)/2转为i+(j-i)/2
     * 3. 如何确定时间复杂度和空间复杂度
     */
    public static int binarySearchBasic(int[] a, int target) {
        int i = 0; // i表示剩余查找的数组开始索引
        int j = a.length - 1; // j表示剩余查看数组的结束索引，[i,j]注意是左闭右闭。
        while (i <= j) { // 判断剩余查找的数组中元素个数是否至少为1
            int m = i + (j - i) / 2; // 求中间索引m
            if (target < a[m]) { // 如果目标值小于中间索引处的值
                j = m - 1; // 则表示m处及m右边的所有元素都大于目标值，都可以直接被抛弃。现在将剩余查找数组的结束索引改为m-1，所以j = m-1
            } else if (target > a[m]) { // 如果目标值大于中间索引处的值
                i = m + 1; // 则表示m处及m左边的所有元素都小于目标值，可以直接被抛弃。现在将剩余查找数组的开始索引改为m+1，所以i = m+1
            } else { // target == a[m] 正好中间索引m的值等于目标，我们直接返回中间m索引即可。
                return m; // 此时m就是我们要寻求的目标索引
            }
        }
        return -1; // 代码可以执行到此处，表示剩余查找的数字元素个数已经小于1了，也就是没有元素符合要求了，表示整个数组里面就没有等于目标元素的数字，我们返回-1即可。
    }

    /**
     * 二分查找 改进版本
     *
     * @param a      被查找的升序数组
     * @param target 需要被找到的目标元素值
     * @return 目标元素值的数组索引下标（如果没有找到元素，则索引下标返回-1）
     * 时间复杂度：O(logN)
     * 空间复杂度：O(1)
     * 知识点：
     * 1. 当 j = a.length时，下面的循环条件如何更改，j值如何更改
     */
    public static int binarySearchImproved(int[] a, int target) {
        int i = 0; // i表示剩余查找的数组开始索引
        int j = a.length; // j表示剩余查看数组的结束索引+1，[i,j)注意是左闭右开。
        while (i < j) { // 因为j表示的数组最后一个元素+1的位置，之前时i<=j，i=j时表示只剩下一个元素了，现在就要改成i<j表示只剩下一个元素了
            int m = i + (j - i) / 2; // 求中间索引下标
            if (target < a[m]) { // 如果目标值小于中间索引处的值
                j = m; // 则表示m处及m右边的所有元素都大于目标值，可以直接被抛弃。现在将剩余查找数组的结束索引改为m-1，所以j = m - 1 + 1 = m;
            } else if (target > a[m]) { // 如果目标值大于中间索引处的值
                i = m + 1; // 则表示m处及m左边的所有元素都小于目标值，可以直接被抛弃
            } else { // target == a[m]，正好中间索引处的值等于目标值，我们直接返回中间索引即可。
                return m;
            }
        }
        return -1;
    }

    /**
     * 二分查找 平衡版本
     * 解决了在右边找不到的最差情况的效率问题
     * 使得无论什么情况，比较次数都是logn
     */
    public static int binarySearchBalance(int[] a, int target) {
        int i = 0; // i表示剩余查找的数组开始索引
        int j = a.length; // j表示剩余查看数组的结束索引+1，[i,j)注意是左闭右开。
        while (1 < j - i) { // 要求数组内元素个数必须大于1，也就是至少还要2个元素
            int m = i + (j - i) / 2; // 求中间索引下标
            if (target < a[m]) { // 如果目标值小于中间索引处的值
                j = m; // 则表示m处及m右边的所有元素都大于目标值，可以直接被抛弃。因为这里j的定义为剩余查看数组的结束索引+1，所以这里不能设置j = m -1，是 m -1 +1 = m.
            } else { // target >= a[m]，如果目标值大于等于中间索引处的值，注意这里包含了等于
                i = m; // 则表示m左边的所有元素都小于目标值，可以直接被抛弃。主要因为包含了等于，所以m不能被排除掉，所以这里设置为i = m，而不是之前的i =m +1;
            }
        }
        return a[i] == target ? i : -1; // 如果数组内元素只有一个1了，就判断最后这个元素是否等于目标值，如果等于，则返回这个索引，否则返回-1。
    }

    /**
     * 二分查找 查询最左边符合要求的元素下标
     */
    public static int binarySearchLeftmost(int[] a, int target) {
        int i =0; // i表示剩余查找的数组开始索引
        int j = a.length -1; // j表示剩余查看数组的结束索引，[i,j]注意是左闭右闭。
        int c = -1; // c表示最左边符合目标元素的下标值，初始化为-1，表示没有找到
        while (i <= j) { // 判断剩余查找的数组中元素个数是否至少为1
            int m = i + (j - i) / 2; // 求中间索引m
            if (target < a[m]) { // 如果目标值小于中间索引处的值
                j = m - 1; // 则表示m处及m右边的所有元素都大于目标值，可以直接被抛弃。现在新的目标结束索引因为为m-1，所以j = m -1;
            } else if (target > a[m]) { // 如果目标值大于中间索引处的值
                i = m + 1; // 则表示m处及m左边的所有元素都小于目标值，可以直接被抛弃。现在新的目标开始索引因为为m+1，所以i = m +1;
            } else { // target == a[m] 如果中间索引m的值等于目标
                c = m; // 则先将符合目标元素的下标保存起来，并继续向左查找，直到找到最左边的符合目标元素的下标。
                j = m - 1; // 因为我们是要查询最左边的符合目标元素的下标，所以m以及m右边的元素都可以被抛弃了，现在剩余查找数组的结束索引为m-1，所以j = m -1;
            }
        }
        return c; // 最后剩余查找数组的元素为0了，表示没有数据都被查找过了，就可以返回最后一次得到的c值了。
    }

    public static int binarySearchLeftmost2(int[] a, int target) {
        int i = 0; // i表示剩余查找的数组开始索引
        int j = a.length - 1; // j表示剩余查看数组的结束索引，[i,j]注意是左闭右闭。
        while (i <= j) { // 判断剩余查找的数组中元素个数是否至少为1
            int m = (i + j) >>> 1; // 求中间索引m
            if (target <= a[m]) { // 如果目标值小于等于中间索引处的值
                j = m - 1; // 则表示可以已经出现符合目的元素，但是因为我们要找的是最左边符合目标值的元素，所以现在还需要继续往左边查找。
                // m处右边的元素无论是否存在目标元素，都不需要了，所以新的剩余数组结束索引为m-1，那么j = m -1;
                // 当i=j时，如何代码能执行到此处，表示
            } else { // target > a[m]，如果目标值大于中间索引处的值
                i = m + 1; // 则表示m处及m左边的所有元素都小于目标值，可以直接被抛弃。现在新的目标开始索引为m+1，所以i = m +1;
            }
        }
        return i;
    }

    /**
     * 二分查找 查询最右边符合要求的元素下标
     */
    public static int binarySearchRightmost(int[] a, int target) {
        int i =0; // i表示剩余查找的数组开始索引
        int j = a.length -1; // j表示剩余查看数组的结束索引，[i,j]注意是左闭右闭。
        int c = -1; // c表示最左边符合目标元素的下标值，初始化为-1，表示没有找到
        while (i <= j) { // 判断剩余查找的数组中元素个数是否至少为1
            int m = i + (j - i) / 2; // 求中间索引m
            if (target < a[m]) { // 如果目标值小于中间索引处的值
                j = m - 1; // 则表示m处及m右边的所有元素都大于目标值，可以直接被抛弃。现在新的目标结束索引因为为m-1，所以j = m -1;
            } else if (target > a[m]) { // 如果目标值大于中间索引处的值
                i = m + 1; // 则表示m处及m左边的所有元素都小于目标值，可以直接被抛弃。现在新的目标开始索引因为为m+1，所以i = m +1;
            } else { // target == a[m] 如果中间索引m的值等于目标
                c = m; // 则先将符合目标元素的下标保存起来，并继续向右查找，直到找到最右边的符合目标元素的下标。
                i = m + 1; // 因为我们是要查询最右边的符合目标元素的下标，所以m以及m左边的元素都可以被抛弃了，现在剩余查找数组的开始索引为m+1，所以i = m -1;
            }
        }
        return c; // 最后剩余查找数组的元素为0了，表示没有数据都被查找过了，就可以返回最后一次得到的c值了。
    }

    public static int binarySearchRightmost2(int[] a, int target) {
        int i = 0;
        int j = a.length - 1;
        while (i <= j) {
            int m = (i + j) >>> 1;
            if (target >= a[m]) {
                i = m + 1;
            } else {
                j = m - 1;
            }
        }
        return i;
    }

}
